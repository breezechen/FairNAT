FAIRNAT README

Source: http://www.metamorpher.de/fairnat/

                             Fair NAT for Linux Routers

  What's this?

   This mini-page is the home of my linux router shaper script which allows
   something like fair bandwidth sharing among clients in the local network.
   The script is not great or anything, I just thought I'd publish it because
   many people helped me write it and maybe someone has some use for it. Sorry
   about the crappy design of this page, I don't have time to put more effort
   in better looks.

  Network

   Here's a very basic ASCII-art which shows my network situation:
                 +-----+
    +--------+   |  S  |
    | User A |---+  W  |
    +--------+   |  I  |
    +--------+   |  T  |     +--------+        +----------+
    | User B |---+  C  +-----| Router |--------| Internet |
    +--------+   |  H  |     +--------+        +----------+
       ....     ... / ...
    +--------+   |  H  |
    | User N |---+  U  |
    +--------+   |  B  |
                 +-----+

  Problem

   You have a certain number of Clients (User A - User N) in your LAN which
   are connected by a Switch (or a Hub or BNC) to the Linux Router which is
   supposed to act as a gateway to the internet. The trouble now is, User B
   has a lot of downloads running and User C uploads stuff day and night,
   which leaves User A who only wants to use an interactive SSH shell in the
   rain, since B and C already use up all bandwidth the internet connection
   offers.

  Solution

   What we need to do is to share available bandwidth fairly among clients. In
   order to achieve this, I first tried several searches at Google and
   Freshmeat. This turned up quite a lot of results, like the Linux Advanced
   Routing & Traffic Control HOWTO which is a must-read and also contains
   great scripts, like the Wondershaper for single users. Another great
   general purpose script I found was HTB.init, which doesn't do anything by
   default, but gives you an easy way to setup HTB queues. In case you prefer
   CBQ, there's a CBQ.init too. If you don't know what I'm talking about, read
   the HOWTO above or continue reading here.

  Script

   Since I never found a script that did exactly what I wanted, I decided to
   write my own. It's designed to be an all-I-need script, therefore it does
   not just setup Traffic Shaping, but Masquerading and Port Forwarding too.
   In short, it does everything that has to do with IPTables and Traffic
   Control. I use HTB (Hierarchical Token Bucket) to share bandwidth among
   clients (one class per client). On top of that I added a PRIO queue to
   prioritize interactive traffic on a per-user basis. On top of PRIO I set
   SFQ to treat connections fairly. In version 0.72, experimental support for
   IPP2P to recognize peer-to-peer traffic was added.

   This is the simplified class setup for per user I use:
    HTB class (for bandwidth sharing)
    |
    \-- PRIO (for prioritizing interactive traffic)
        |
        \--- Interactive:  SFQ (to treat concurrenct connections fairly)
        \--- Normal:       SFQ
        \--- High-Traffic: SFQ

  What you can and what you can't expect

   Without traffic shaping, users with low-traffic, interactive connections
   experience ping times between 2-5 seconds, when other users have up- and
   downloads running. This is of course deadly for SSH connections. You can't
   work on remote machines like that. With my script, I get much lower pings,
   at about 100-200ms. Compared to the 2000-5000ms before, this is a huge
   improvement. However, considering that the ping on a free line would be at
   around 50ms, the connection still feels laggy. It's nearly impossible to
   make perfect interactive connections if the line is maxed out in both
   directions.

  Requirements

   For this script, you need iptables, tc and a QoS-enabled kernel. All these
   binaries must support HTB. It may be possible that you need a patched
   version of tc for that. I also use several kernel patches: The TTL patch,
   which allows me to modify the TTL value of packets. If you don't want this,
   it has no effect on shaping whatsoever. Then I use PSCHED_CPU instead of
   PSCHED_JIFFIES for scheduling. Just replace it in pkt_sched.h. Check Stef
   Coene's docum page for details. It probably will work without that, too. I
   also lowered the default SFQ queue length from 100 to 16. Again, more
   information at Stef's page.

  Configuration

   Of course, in order to use my script, you first have to configure it. As
   long as you are in the same network situation (see above) and have the same
   requirements as I do (you tell me), this should be fairly simple to do. You
   have to set these variables in the script's configuration file (default:
   /etc/ppp/fairnat.config). You have to edit the script itself if you want
   another location for the configuration file.

   Configuration of your LAN and Clients:
     * DEV_LAN: Device of your LAN (default: eth1)
     * USERS: Which clients are allowed to use the router (default: "2 5 6 23
       183". If your router is in the 192.168.100 subnet, it will expand to
       192.168.100.2, 192.168.100.5, and so on) Grouping is now possible, too.
       For example, if you use 3:7:9:10, it assigns the IPs 3 7 9 and 10 to a
       single user. Useful if you got someone with multiple machines in your
       LAN.
     * PORTS: Ports to be forwarded (default: "2 4000:6999 183 2000:3999",
       which means that ports 4000-6999 are forwarded to client 192.168.100.2,
       whereas ports 2000-3999 are forwarded to client 192.168.100.183)
     * RATE_LAN: The speed of your local area network (default: 2Mbit)

   Configuration of your Internet device:
     * DEV_NET: Your internet device (default: ppp0)
     * RATE_UP: Your upstream bandwidth (default: 128kbit (ADSL))
     * RATE_DOWN: Your downstream bandwidth (default: 768kbit (ADSL))

  Command line arguments

   Currently, the following arguments are understood:
     * stop: Resets IPTables and Traffic Shaping to zero.
     * info: Shows information about your current configuration.
     * <config-file>: This file will be used instead of the default
       configuration file. Please note that if you use this feature, you have
       to specify the file when using the stop and info parameters too. (It's
       probably easier to change the FAIRNAT_CONFIG variable directly in the
       script)

  IPP2P support (EXPERIMENTAL)

   Let me add some notes about the IPP2P support introduced in Fair NAT v0.72.
   IPP2P provides a (more or less) reliable means to detect traffic of
   peer-to-peer (filesharing) applications. To use it, you first have to patch
   the kernel and the iptables program. You can get the patches at the
   Official IPP2P Homepage along with plenty documentation. When that's done,
   you have to enable IPP2P in the Fair NAT configuration file, too. See the
   example configuration file for details.

   Please note that IPP2P also requires the CONNMARK patch, unless you intend
   to drop all P2P packets in general. Applying this patch can be a pain in
   the ..., it took me several days to do it properly. If you use the newest
   version of the CONNMARK patch, you also need a new version of iptables - at
   least version 1.2.10 (at the moment, you need iptables-cvs). Otherwise
   CONNMARK won't work - you'll get an 'Invalid Argument' error. Another
   solution would be using an OLD version of the CONNMARK patch, but I haven't
   found any that worked together with kernel 2.4.26 so far. The patch is part
   of patch-o-matic-ng which you can get on the Official Netfilter Homepage .

   If IPP2P is enabled, Fair NAT uses it like this. If P2P traffic is
   forbidden in general, all packets recognized by IPP2P are dropped. End of
   story. Bye bye. However, if P2P traffic is allowed, Fair NAT does the
   following:
     * Mark and remember all P2P connections using CONNMARK.
     * Mark all packets of P2P-marked connections
     * Use 4 instead of 3 prio bands per user.
     * If a packet is marked as P2P, use $USER_MARK+1 as new package mark
       instead of $USER_MARK
     * Put all $USER_MARK+1 packages into prio band 4. Bands 1-3 still depend
       on TOS.

   This way, P2P traffic is not limited at all, but gets an even lower
   priority than HTTP traffic or FTP transfers. If you don't know what all
   this marking stuff is, don't bother. It's just the identifier that tells
   the Traffic Shaping mechanism which packet belongs to which user.

  Download

   The script can be found here: (newest version recommended)
     * fairnat-0.72 (minor bugfixes, experimental IPP2P support)
     * fairnat-0.71 (Class numbers are now derived from user IP instead of
       array index. This makes it much easier to read class-based statistics.
       Thanks to Udo for the suggestion.)
     * fairnat-0.70 (User grouping allows multiple IPs per user. Thanks to
       Tomasz for the suggestion. Added command line arguments stop, info,
       <config-file>)
     * fairnat-0.69
     * fairnat-0.68

   Please take the time to read the comments directly in the script,
   especially in the sample configuration file, too. I tried to add loads of
   comments in case you want to modify some parts of the script. If you find
   bugs and/or improvements or have other suggestions or questions, please
   contact me: Andreas.Klauer@metamorpher.de

  Credits

   Thanks to all those people who helped me write this script. Special thanks
   to the authors of the LARTC Howto and the people on the LARTC mailing list.
   And of course to Stef Coene for his great page.

  TODO

     * Allow creation of subclasses for grouped IPs. Currently, bandwidth
       sharing between multiple machines of the same user doesn't perform too
       well because all the traffic is put into the same class.
     * Make IPP2P support more powerful, like disabling P2P traffic on a user
       and/or protocol basis.
     * Read mailing lists, kernel changelog and other scripts in order to find
       hints for new, better methods and other improvements.
     ______________________________________________________________________

  Other projects

     * burn-dvd-image.sh : Simple script that uses a combination of growisofs,
       pipebuf and nice to make high speed DVD image burning under heavy load
       conditions possible. If you use growisofs, and experience speed
       breakins (reported writing speed is not constant), this is probably the
       right script for you.


Source: http://www.metamorpher.de/fairnat/
